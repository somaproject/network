\section{NIC Configuration and Management Interface}
The NIC uses a SPI-like four-wire serial interface for control of MAC parameters, error statistics, and direct interface to the MDIO PHY Interface. This configuration and 


The following signals provide the serial interface. All data is sent MSB first. 
\begin{itemize}
\item \signal{SCLK} The slow (< 1 MHz) serial clock. This line is latched and sampled by synchronous logic, thus it can be a discontinuous or asymmetric clock.
\item \signal{SCS} The active-low chip select signal; this is used to frame a command word. This line must be asserted (low) for a serial command to have any effect. 
\item \signal{SIN} : Serial in. First the 8 address bits are clocked in, followed by either 32 input data bits or 32 output bits placed on SOUT.
\item \signal {SOUT} serial output
\end{itemize}

Each serial command word consists of a direction bit, an address, and the either the input or output 32-bits of data. 


\begin{timing}{memorywrite}
C: SCLK    :  |  |  |  |  |  |  |  |  |  |   |   |   |   |  
S: SCS     :  H  L  L  L  L  L  L  L  L  L   L   L   L   L  
B: SIN     :  Z  RW X  A5 A4 A3 A2 A1 A0 D31 D30 D29 D28 D27 
BC:        :  0  1  0  1  1  1  1  1  1  2   2   2   2   2
B: SOUT    :  Z  Z  Z  Z  Z  Z  Z  Z  Z  D31 D30 D29 D28 D27
BC:        :  0  0  0  0  0  0  0  0  0  3   3   3   3   3 
\end{timing}

For a write (RW=1) the register with address \signal{A[5:0]} takes on the data clocked by SIN. Similarly, if RW=0, we take the output data on SOUT. 

\section{Control Registers}

--------------------------------------------------------------------------
PHY CONTROL INTERFACE
--------------------------------------------------------------------------
The PHY status registers can be read/written over the MII interface, a sad stressful I2C-like IO. Described in 22.2.4 of the 802.3 Ethernet standard (make sure you have the GIG-E one)


MII_interface.vhdl:
Creats  5-bit ADDR and 16-bit parallel input(DIN) and output(DOUT), and RW  interface for the MII interface on the phy. A bit of a hack, uses a very crude lookup-table FSM. But it works. START high starts it, DONE signals that it's done. 

PHY Status continually loops over the following PHY addresses:
1. 0x11 read (vendor-specific Link and Auto-negotiate LINK_AN (vendor-specifc))
2. 0x0F read (extended-status 1KSCR)
3. PHYADDR (for read and write): user-selected

Thus we are continually reading the above-listed values and sticking them in PHYSTATUS along with DOUT. PHYSTATUS=[1KSCR : LINK_AN]


The state machine begins by reading PHY status registerrs, and then if PHYARDDRWS is high (ie.. the PHYADDR registers have been written recently) we go to the MIIIO section of the FSM where we read the relevant data.

--------------------------------------------------------------------------
ADDRESSES
--------------------------------------------------------------------------
AD: Signal:     Generated by:  Meaning:
10  RSTCTR                     Reset counters, per bits. 
11  TXF         TXoutput        A frame was successfully transmitted 
12  RXF         RXinput         A frame was successfully received
13  TXFIFOWERR  TXinput         TX (memory) FIFO write error
14  RXFIFOWERR  RXinput         RX (memory) FIFO write error 
15  RXPHYERR    RXinput         RX phy error, caused by PHY asserting RX_ER
16  RXOFERR     RXinput         RX small async fifo overflow
17  RXCRCERR    RXinput         RX valid packet received with bad checksum

00  No Op (returns 0x01234567)
01  Reset PHY 
    Reset phy uses an 8-bit counter that resets to 255 and then counts down to 0. While it is not zero, PHYRESET is high, thus we hold the reset pin low for 255ticks of the slower clock. 

02 PHYSTATUS 
03 no op (returns 0x89ABCDEF)
04 address out debug
05 memory in debug
06 rx buffer pointer and rx feedback bp
07 tx buffer pointer and tx feedback bp

We also have the:
08 PHYADR address register (write) (5 LSBs)
09 PHYDI data in register (16 LSBS) -- write to this register to write to phy
0A PHYDO data out register (16 LSBS)


So, the lower 5 bits of PHYADR is the address we're trying to read to or write from, and the 6th bit is whether it's a read (PHYADR{5]=0) or a write(PHYADR[5]=1). The 31st bit is the status. When it goes high, the most recent transaction is complete. The read of ADDR when the status bit is high will clear it. To make this work, we toggle the PHYADDRR signal simultaneously with the latching of DOUT via DOUTEN. This way we avoid the race condition of latching DOUTEN and then having the PHYADDRSTATUS bit set after that, and then letting the NEWCMD clear it. 

Note that this means you should (for a write) WRITE the PHYDO register with the data you want to transmit, and then write the PHYADDR with PHYADR[5]=1. To read, you write the PHYADR register (with PHYADR[5]=0), then continue to read ADDR until the status bit goes high, at which point the data in PHYDI is valid.

and then we have (maybe someday) settings related to MAC address filtering
19 ALLF     1 if we wish to receive all packets (default 1)
1A RXBCAST  1 if we wish to receive broadcast packets
1B RXMCAST  1 if we wish to receive multicast packets
1C RXUCAST  1 if we wish to receive unicast packets
1D MACADDR1 bottom 16 bits of MAC address
1E MACADDR2 middle 16 bits of MAC address
1F MACADDR3 top 16 bits of MAC address
