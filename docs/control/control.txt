Configuration and management interface


The NIC uses a SPI-esque serial interface to interact with a number of internal registers, including the state registers on the PHY. We control counters, phy state, MAC addresses, and the like through this interface. This also handles toggling the various flashing LEDs and what they actually mean. Everything in the unit is gated to the /8 clock enable, allowing for relaxed timing constraints. 

------------------------------------------------------------------------------
GENERIC SERIAL IO
------------------------------------------------------------------------------

The following signals provide the serial interface. All data is sent MSB first. 

SCLK: slow (< 1 MHz) serial clock. This line is latched and sampled by synchronous logic, thus it can be a discontinuous or asymmetric clock. The result is that SCLKDELTA represents a "new" clock pulse, and NEWCMD toggles high after the 40th clock bit. 

SCS : The chip select line; while high this line continually resets the bit counter. SCSlow alows for the counter to increment. Thus SCS must be low during the entirity of any transaction.

SIN : Serial in. First the 8 address bits are clocked in, followed by either 32 input data bits or 32 output bits placed on SOUT.

SOUT : serial output

The ADDR register contains the 8 address bits, with the MSB actually indicating whether this is a read or a write (i.e. ADDR[7] = RW). Only the 6 LSBs of ADDR are ever really checked, however, so there are really only 32 possible device addresses.

The 6 LSBs of ADDR determine the value on DOUTMUX, per the address map below. 

The various written-to peripherals simply compare RW, ADDR bits, and NEWCMD. 


----------------------------------------------------------------------------
LED indicators
----------------------------------------------------------------------------
Various state signals (TXF, etc.), once they cross into our domain, are used to load 12-bit counters to their maximum values, which then light the LED until they hit zero (thus are visible)

--------------------------------------------------------------------------
COUNTERS
--------------------------------------------------------------------------
The various 32-bit counters employ a similar stategey to the LEDS, and cross clock domains in a similar manner. 

--------------------------------------------------------------------------
PHY CONTROL INTERFACE
--------------------------------------------------------------------------

PHY Status continually loops over the following PHY addresses:
1. 0x11 read (vendor-specific Link and Auto-negotiate LINK_AN (vendor-specifc))
2. 0x0F read (extended-status 1KSCR)
3. PHYADDR (for read and write): user-selected

Thus we are continually reading the above-listed values and sticking them in PHYSTATUS along with DOUT. PHYSTATUS=[1KSCR : LINK_AN]


The state machine begins by reading PHY status registerrs, and then if PHYARDDRWS is high (ie.. the PHYADDR registers have been written recently) we go to the MIIIO section of the FSM where we read the relevant data.

--------------------------------------------------------------------------
ADDRESSES
--------------------------------------------------------------------------
AD: Signal:     Generated by:  Meaning:
10  RSTCTR                     Reset counters, per bits. 
11  TXF         TXoutput        A frame was successfully transmitted 
12  RXF         RXinput         A frame was successfully received
13  TXFIFOWERR  TXinput         TX (memory) FIFO write error
14  RXFIFOWERR  RXinput         RX (memory) FIFO write error 
15  RXPHYERR    RXinput         RX phy error, caused by PHY asserting RX_ER
16  RXOFERR     RXinput         RX small async fifo overflow
17  RXCRCERR    RXinput         RX valid packet received with bad checksum

00  No Op (returns 0x01234567)
01  Reset PHY 
    Reset phy uses an 8-bit counter that resets to 255 and then counts down to 0. While it is not zero, PHYRESET is high, thus we hold the reset pin low for 255ticks of the slower clock. 

02 PHYSTATUS 
03 no op (returns 0x89ABCDEF)
04 address out debug
05 memory in debug
06 rx buffer pointer and rx feedback bp
07 tx buffer pointer and tx feedback bp

We also have the:
08 PHYADR address register (write) (5 LSBs)
09 PHYDI data in register (16 LSBS) -- write to this register to write to phy
0A PHYDO data out register (16 LSBS)


So, the lower 5 bits of PHYADR is the address we're trying to read to or write from, and the 6th bit is whether it's a read (PHYADR{5]=0) or a write(PHYADR[5]=1). The 31st bit is the status. When it goes high, the most recent transaction is complete. The read of ADDR when the status bit is high will clear it. To make this work, we toggle the PHYADDRR signal simultaneously with the latching of DOUT via DOUTEN. This way we avoid the race condition of latching DOUTEN and then having the PHYADDRSTATUS bit set after that, and then letting the NEWCMD clear it. 

Note that this means you should (for a write) WRITE the PHYDO register with the data you want to transmit, and then write the PHYADDR with PHYADR[5]=1. To read, you write the PHYADR register (with PHYADR[5]=0), then continue to read ADDR until the status bit goes high, at which point the data in PHYDI is valid.

and then we have (maybe someday) settings related to MAC address filtering
19 ALLF     1 if we wish to receive all packets (default 1)
1A RXBCAST  1 if we wish to receive broadcast packets
1B RXMCAST  1 if we wish to receive multicast packets
1C RXUCAST  1 if we wish to receive unicast packets
1D MACADDR1 bottom 16 bits of MAC address
1E MACADDR2 middle 16 bits of MAC address
1F MACADDR3 top 16 bits of MAC address
