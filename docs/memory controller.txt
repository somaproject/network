MEMORY CONTROLLER:

This is the basic memory controller; some of the coding decisions were made in an attempt to get the inputs and outputs to synthesize correctly. 

In particular, the correc tristating is designed to interface properly with the cypress ZBT SRAM. 

For each port there is a 17-bit addr, and a 32-bit input (D) and output (Q). The four clock enables (CLKEN1-CLKEN4) are generated inside the memory controller. CLKENn going high means that the input to Dn, ADDRn, and WEn will be captured on the next clock cycle. The controller handles correct piplining of the input data, however, the user is responsible for dealing with the output data. This is to allow application-dependent burst reading. 

At the moment, we make this all work by driving mclk with an inverter -- this gives us no bit errors. Further research will be necessary to determine why this is the case, and if it will continue to work in the large-scale design.  

The worst part is keeping the timing parameters in check. 

Test1: increment address, increment data, use different offsets, stresses 64kwords at a time. 

Test2: test1 with LFSRs...

Test3: We write in a bucketload of data (2^15 different words) and then we read it out. Designed to check for artifacts of sequential access. 

